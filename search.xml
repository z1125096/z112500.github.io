<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Jenkins持续集成]]></title>
    <url>%2F2019%2F04%2F02%2FJenkinsContinuous%2F</url>
    <content type="text"><![CDATA[Jenkins是一个非常好用的工具，我们可以用它来帮我们做很多事，如：自动构建、发布测试、持续集成、邮件通知等等很多很多，真是开发者的一个得力帮手。很多同学还不会使用，本文将从零开始，带你半小时上手，轻松搞定繁琐的配置。 1.安装Jenkins有很多安装方式，通常windows我们使用msi安装包，linux下则使用rpm windows:傻瓜式操作，不叙述了。通常我们都在自己电脑上用，安装完成直接到启动Jenkins linux： 1.1安装 12上传文件rpm -ivh jenkins-xxx.noarch.rpm 1.2配置Jenkins 返回根目录，用find / -name jenkins搜索jenkins相关目录 如： 1234567/etc/sysconfig/jenkins/etc/rc.d/init.d/jenkins/etc/logrotate.d/jenkins/var/lib/jenkins/var/log/jenkins/var/cache/jenkins/usr/lib/jenkins 配置jdk，在candidates后面加上自己的jdk路径，如下： 1vi /etc/rc.d/init.d/jenkins 123456789candidates="/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java/usr/local/java/jdk1.8.0_181/bin/java" 1.3 修改端口 1vi /etc/sysconfig/jenkins 1.4 启动Jenkins 1service jenkins start 问题1： 启动时，可能出现端口错误，Jenkins的默认端口是8080，检查是否有其他程序，例如Tomcat是否占用8080端口 问题2： 出现以下提示，执行命令，重新加载即可： 1systemctl daemon-reload 2.启动Jenkins启动成功后会让你输入默认密码，有文件位置，打开就能看到，一般默认插件都装上，设置一个管理员帐号。重新登录就安装完成了。 3.新建任务这里以新建maven项目做示例，一开始是没办法建maven项目的，我们要先安装插件 3.1 安装插件我们要用到的插件（有些可能默认已经安装） 123456Maven Integration plugin //mavenPublish Over SSH //重要，ssh#下面可选Subversion Plug-in //svnGit plugin //gitThinBackup //备份用 3.2 新建任务主页点击“新建”项目类型：输入项目名称 demo，类型选择“构建一个Maven项目”(如果没有此项可选，请检查插件“Maven Integration plugin”是否已安装)； 3.3 配置任务1.配置源码，一般没问题2.配置定时构建定时构建或者轮询构建（源码提交定期检测），一般我们选前者 “日程表”格式与 crontab 相似但有细微差别，示例如下： 123456789101112131415161718192021222324252627282930## 每行由 5 个值组成(空格或TAB分隔)，分别表示分(0-59)、时(0-23)、日(1-31)、月(1-12)、周(0-7, 0/7=周日)## "M,N" 表示M和N；"M-N" 表示范围[M,N]；"M-N/X" 表示范围[M,N]内每隔X；"*/X" 表示整个范围内每隔X## 前面提到的M/N/X的值都可以用H(意为Hash)代替，散列值起到随机值的效果，且同一项目取值稳定，这对于项目多时分散压力很有用。H/10 H(0-8) * * 1-5 ## 触发时间: 工作日、Hour为0~8按哈希随机、Minute以10为间隔H/10 H * * 0,6,7 ## 触发时间: 周末、Hour为全天按哈希随机、Minute以10为间隔## “日程表”修改后，下方会给出下次执行时间点的预告##下面是一些例子每天凌晨2:00跑一次 H 2 * * *每隔5分钟构建一次H/5 * * * *每两小时构建一次H H/2 * * *每天中午12点定时构建一次H 12 * * * 或0 12 * * *（0这种写法也被H替代了）每天下午18点前定时构建一次H 18 * * * 每15分钟构建一次H/15 * * * * 或*/5 * * * *(这种方式已经被第一种替代了，jenkins也不推荐这种写法了) 周六到周日，18点-23点，三小时构建一次H 18-23/3 * * 6-7 3.Build输入Root POM和Goals and options，如pom.xml和clean install 4.构建后操作选择Send build artifacts over SSH(要提前去设置好ssh服务器，设置好可以点击测试) 填写SSH服务器相关配置 123Name:选择服务器Source files:要上传的文件，这里我只要上传jar，填`xxx/target/*.jar`Remote directory: 远程文件夹位置，最好先新建好，否则可能报错，如`/home/jenkins/demo` Exec command:执行命令,注意的是sh脚本要写上jdk环境变量，因为Jenkins的线程马上就会被服务器杀死而无法获取环境变量 12345cd /home/test/sh app.sh stoprm -rf *.jar logs/cp -r /home/jenkins/test/*.jar ./sh app.sh start app.sh顶部写法，记得chmod +x app.sh赋予执行权限 12345#!/bin/bashexport JAVA_HOME=/usr/local/java/jdk1.8.0_181export JRE_HOME=$JAVA_HOME/jrePATH=$JAVA_HOME/bin:$PATHexport PATH 点击高级，勾上Flatten files,这样不会创建没用的目录 附上tomcat启动脚本示例 1234567891011121314151617181920212223242526272829303132333435#!/bin/bashexport JAVA_HOME=/usr/local/java/jdk1.7.0_79export JRE_HOME=$JAVA_HOME/jrePATH=$JAVA_HOME/bin:$PATHTOMCAT_HOME=`/usr/local/tomcat/consumer/tomcat-8080`SHUTDOWN=$TOMCAT_HOME/bin/shutdown.shSTARTTOMCAT=$TOMCAT_HOME/bin/startup.shecho "关闭$TOMCAT_HOME"$SHUTDOWNsleep 2PIDS=`ps -ef |grep $TOMCAT_HOME |grep -v 'grep'|awk '&#123;print $2&#125;'`if [ -z "$PIDS" ] then echo "STOP SUCCESS!" else kill -9 $PIDS echo "KILLED PID: $PIDS"fisleep 2#if you need to remove logs#rm -rf $TOMCAT_HOME/logs/* #if you need to remove works#rm -rf $TOMCAT_HOME/wrok/*#remove old warrm -rf $TOMCAT_HOME/webapps/*#cp your war filecp -r /home/jenkins/demo/*.war $TOMCAT_HOME/webapps/echo "start $TOMCAT_HOME"$STARTTOMCATPIDS=`ps -ef |grep $TOMCAT_HOME |grep -v 'grep'|awk '&#123;print $2&#125;'`echo "STARTED PID: $PIDS"#tail -f $TOMCAT_HOME/logs/catalina.out 授人以鱼不如授人以渔，希望小伙伴们能举一反三！ 5.tags标签用法因为少数人会用到，所以放在后面 svn用法 在常规设置出勾选参数化构建过程 选择List Subversion tags Name输入SVN_TAG Repository URL输入tags地址，如https://192.168.0.xx/svn/test/tags 选择帐号密码 勾选Sort newest first 源码管理中Subversion的URl改成https://192.168.0.xx/svn/test/tags/$SVN_TAG` git用法相对简单 安装git-parameter插件 参数化构建选择Git Parameter Name输入tag,Default Value输入origin/master或者不填 源码管理中Git的Branch Specifier值填${tag}，与上面对应 6.邮件通知 安装插件Email Extension Plugin（最新版本可能默认集成） 进到系统管理-&gt;系统设置 Jenkins URL：jenkins根据这个URL在邮件中显示图片及链接，如一些构建日志，构建任务的工作区间等等可通过该链接访问 同样在系统设置中，配置Extended E-mail Notification： Default Content Type：邮件内容格式，可选Plain text和HTML。 Default Recipients：默认的收件人列表，用逗号分隔。抄送或密送某个收件人可以在其邮箱前面加上cc:或bcc:。 Default Subject：默认的邮件标题。【构建通知】：$PROJECT_NAME - $BUILD_STATUS - Build # $BUILD_NUMBER! Default Content：默认的邮件内容。这里提供一个模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;$&#123;ENV, var="JOB_NAME"&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志&lt;/title&gt;&lt;/head&gt; &lt;body leftmargin="8" marginwidth="0" topmargin="8" marginheight="4" offset="0"&gt; &lt;table width="95%" cellpadding="0" cellspacing="0" style="font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif"&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color="#0B610B"&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称 ： $&#123;PROJECT_NAME&#125;&lt;/li&gt; &lt;li&gt;构建编号 ： 第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt; &lt;li&gt;SVN 版本： $&#123;SVN_REVISION&#125;&lt;/li&gt; &lt;li&gt;触发原因： $&#123;CAUSE&#125;&lt;/li&gt; &lt;li&gt;构建日志： &lt;a href="$&#123;BUILD_URL&#125;console"&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建 Url ： &lt;a href="$&#123;BUILD_URL&#125;"&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;工作目录 ： &lt;a href="$&#123;PROJECT_URL&#125;ws"&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目 Url ： &lt;a href="$&#123;PROJECT_URL&#125;"&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color="#0B610B"&gt;变更集&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;$&#123;JELLY_SCRIPT,template="html"&#125;&lt;br/&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; Enable Debug Mode：开启插件的Debug模式，在日志里能看到更多信息。 其他配置保持默认即可。 这里的Default Content Type笔者选择了HTML，因为可以显示更为好看丰富的邮件内容，另外邮件内容中用到了一些Jenkins的内置变量，有兴趣的童鞋可以自行百度。 在构建后添加Editable Email Notification，填好相关的内容，要注意需要添加Triggers，没有添加Triggers就不会发送通知邮件出来，这是一个触发条件。主要添加的Triggers有三类：Failure-Any，Success，Unstable (Test Failures)，分别对应构建失败，构建成功，构建不稳定时触发发送邮件通知。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员怎样升职]]></title>
    <url>%2F2017%2F08%2F24%2FHowToPromote%2F</url>
    <content type="text"><![CDATA[在知乎上看到一个过2k赞的回答，觉得讲的非常好，和我的经历也很像，特此分享给大家。直达原文内容如下（部分排版和错误修改）：我是码农出身，工作十年，从初级程序猿（半年）- 项目主力（一年）- 初级技术管理（一年） - 中级技术管理（两年）- 部门管理（两年）- 高层管理（三年）- 职业经理人，一条路走过来，关于升职，有一些自己的心得可以分享。以下大致说说从技术到管理的转变，暂不涉及管理的进阶。 1. Love Coding 热爱编程大四开始找工作的时候，我正在上一门可视化编程的课，大概就是用VC编写出可以绘图、简单动画和播放多媒体文件等各种操作的程序。基于这门课，我编写了贪吃蛇、俄罗斯方块等各种游戏。另外的一段编程经历是大二时候的Java大作业，编了一个很弱的图片管理器。实际上，这些程序都非常弱智，那时候的我算法极差，代码规范性极差，甚至于对SDK或库函数的掌握也极差，是个地地道道的菜鸟，但这并不妨碍我喜欢编程。我发现，当我坐在电脑前敲代码，或者对着千疮百孔的程序不断调试，打断点，加入调试代码，单步执行查看内存变化的时候，我是乐在其中的，甚至于忘了时间。所以，面临工作方向选择的时候，我毫不犹豫选了coding。 于是，当07年我在缺少指导，对Linux不甚了解，对路由器也一知半解的情况下，开始开发国内厂商的第一代11N路由器的时候，倾注了大量的精力阅读《LDD3》，搞定交换芯片驱动；大段大段的啃Linux Kernel源码，搞定netfilter/iptables；阅读《UNIX环境高级编程》，搞定各种同步互斥进程线程；阅读网上的各种技术博客，包括把竞争对手的GPL代码Down下来仔细阅读。。。一年里加班无数，五一十一也都是在加班中度过，一年下来基本上搞定了领导交给我的艰难任务。然后又用一两个月的时间，把产品上市后爆出来的各种Bug一一解决，最终赢回了市场口碑。 如果没有这种热爱，你就无法在日复一日的coding中保持专注，更不用说脱颖而出。 任何成功背后，都有不为人知的苦闷和寂寞。程序猿的苦逼之处，就在于别人高谈阔论指点江山的时候，别人推杯换盏觥筹交错的时候，别人出差南北纵横内外的时候，别人利用工作之便撩妹泡妞啪啪啪的时候，你只有面对屏幕，把键盘敲的啪啪啪。如果你忍受不了这种寂寞，体会不到其中的乐趣，请尽早换行。程序猿的高潮，来自于屏幕上排版良好的指令，按照你的意志精确执行，并且分毫不差。 2. Know yourself 贵有自知之明，了解自己自知之明这个词，说的容易，做起来特别难。但又特别重要。 以前我团队里有个小伙，非常非常内向，话没说几句就脸红，后来程序猿不干了要去做展会，学跟人打交道，说是要挑战自己。我不知道他后来怎么样，估计结果不太好。人的性格在十几岁的时候基本就定性了，二十几岁的人再想彻底改变自己，极难，有这个毅力，估计什么都能做好了。 扯远了。这一条最想说的是，弄清楚你到底适不适合干程序猿这一行，我多年的经验总结下来，优秀的程序猿都有如下的性格特质（或部分）：细心严谨、细节强迫症、完美主义、做事情有条理、耐得住寂寞、喜欢跟机器跟代码打交道（相比跟人打交道）、口才一般不佳、容易偏激或钻牛角尖、人情世故方面稍显笨拙。与之相对的是销售：口才极佳滔滔不绝、擅长跟人打交道、为人处世圆滑、八面玲珑、说话虚虚实实、为达目的不择手段。所以，适合什么样的职业方向是有章可循的。 仔细想想自己是什么样的人，结合上一条，有没有一颗热爱coding的心，你就能知道自己到底适不适合这一行。 自知之明还体现在，干这一行的过程中，详细了解自己的各项技能的长短，扬长补短。程序猿不是简单会敲代码就行，构思、设计、编码、测试、调试，往往编码只占很小的比例。而且程序猿这一行范围又极广，底层驱动、操作系统、协议栈、前端、服务器、APP、数据库、大数据、分布式、系统集成。。。。。。怎么选择，怎样能够发挥优势，真的应该好好想想。 这一条展开来说，可以讲一天，具体也可以参照我在其他问题下面的回答。职业生涯规划里面，知己知彼是非常非常重要的，知己，即是了解自我的个性、特点、优劣势、需求；知彼，即是了解行业、企业、团队、职位的情况和要求。 3. Be reliable 可靠，说到做到，做好本职作为程序猿，最基本要求是：代码可读性好、功能正常没有明显bug。 但我见过太多这行里的毛头小伙，数字常量到处埋，函数命名用拼音，if else 十层八层嵌套，匈牙利命名法和Linux命名法混杂，代码像挤在一张皱了的纸上，零注释或写完代码补注释，异常处理缺失，还有基本功能一用就崩溃，还辩解说，在我那里是好的呀。遇到这一类人，通常我在心里先给打个D等（ABCD），日后恐难以翻身。 还有稍微进阶一点的毛病，说这个功能包我身上没问题，又或者一周之内绝对给你搞定，领导你放心。最后拿出来的代码不是错漏百出，就是规定时间根本完不成，而且到deadline前你询问他的时候才告诉你搞不定。。。项目组里有这样的人，要么得配一个给他擦屁股的，要么得配一个项目助理时刻监督他，换一句话说，他的贡献值其实为负。 程序猿要想进阶，其实什么设计模式、架构、高深算法、莫测技术都不重要，这些都只是术，或者说套路。最核心的应该是，把简单的任务完成好，之后再完成更难一点的任务，这样你就慢慢进阶了。为了自己的承诺和项目组整体的进度，有的时候，你需要在保证质量的基础上，拼命加班，不负所托。 再补充一点，可靠并不是说绝不出错，是人都会犯错。但你不能重复犯错，相同的错误出现两次，会严重影响别人对你的信心。 4. Work hardest 以绝大多数程序猿的努力程度，还轮不到拼天赋这一点可能会有争议，也会有很多程序猿跳出来说，老子996都不止，一周工作80个小时都有了。并不否认，很多行业里的程序猿，以互联网尤甚，加班是很夸张的。但我想表达的是，你要做你们团队里最努力的那个人，别人工作80个小时，你就工作90个小时。你以为所有爬上去的人都是领导亲戚或是被潜规则？别傻了，如果大家资质差不多，一定是最努力的那个人首先得到机会。领导又不傻，马群里挑一匹跑的最快挑的最重的来带头，肯定会有示范效应，也容易服众。当然，健康是自己的，如何保持足够的休息和锻炼是你必须认真考虑的问题，不是你领导考虑的问题。另外，如果真的资质相差太大，省点力气，排队等机会吧，不行就换行。程序猿这一行里，最牛逼和最平庸之间的生产效率之比大致是50：1。 果然这一点引起了极大的争议。补充一些说明吧，对我来说加班最夸张的一段时间是八点半上班，除去午休一个半小时，晚上十一点下班，差不多持续一个月。我从来都不认同不眠不休的持续高强度加班，所谓的弹性工作制其实是最坑人的，每天工作到夜里一两点然后第二天十点十一点去上班？有意义吗？十二点准时睡觉，第二天八九点准时去上班，想挂掉都没那么容易。这一点很感激前东家死板的考勤制度。 另外，在我的职业生涯里，从来都是提倡快乐工作快乐生活，我所带的部门，篮球羽毛球健身水平都是公司顶尖。最忙的时候我一样一周打球两三次。可现实中一有空不用加班依然打游戏看片呆坐电脑前熬夜的程序猿不在少数。不要为自己不健康和颓废的作息找借口。真正牛逼的人，懂得人生是马拉松而不是百米冲刺的道理。 另外的另外，真的加班到力不从心快要挂了还无法出人头地，换工作吧，不行就换行。你的负能量和颓废气息三个街区外卖烤红薯的大妈都闻得出来。 另外的另外的另外，刚看到春雨医生CEO去世的消息，非常震惊，相比升职，好好活着更为重要，生者共勉。 5. Do the simple things right 再简单的事情都要做好，注重细节你review过的代码里最低级的错误是什么？我遇到很多很多，“==”写成“=”、三个参数只传了俩、“1 &lt;= month &amp;&amp; month &lt;= 12” 写成“0 &lt; month &amp;&amp; month &lt; 12”、不判断返回值就直接下一步调用，太多太多。 写邮件的时候，很多人直接把话都写在标题，内容为空；也有标题空着的，或者叫“经理你好”；或者邮件字体时大时小，一会黑一会蓝，看的人时刻有惊喜。 写文档的时候，busy写成 buzy，该换行分段偏不，该用流程图说明的偏要用文字，好不容易画个流程图，方框里一会是实体一会是操作，箭头各种乱指，你写得出来，别人可看不下去。 这类人，你是老板，你敢提拔他当主管？ 再举一个正面的例子，我的团队里曾经缺乏一个项目助理，不得已选了一个程序猿小伙，让他兼职管管样机、发发通知，小伙没有怨言，除了自己的代码照常写的非常稳妥之外，兢兢业业做好这些小事。后来没多久他就当上了主管。一个有能力把小事做到极致的人，也必定有潜力把大事做好。 6. Be open-minded, don’t be defensive 心态开放，接受他人意见，别人批评建议的时候不要习惯性辩解和说不以前我的团队里有几个同一届毕业的优秀小伙，其中两人，就叫A和B吧。以编程水平、技术广度来衡量，A要更胜一筹，当然B也是杰出的程序猿。按理说，先得到晋升的应该是A，实际上，B很快就连升两级，再后来就带一个大型的团队了，而A始终是最基层的主管。 为什么？我举一些实际的例子。 作为年轻人，免不了有做的不足的地方，通常我都会面对面跟他们具体指出来，B通常会说：“收到，以后我一定注意”、“我不是很明白，能否给我一些具体事例，或者再给我解释一下。。。好的我明白了”、“我的理解是这样的不知道对不对。。。好的知道了”。然后在接下来的一个季度里，你很快就能看到他迅速改进，原来的弱项变成了他的强项。 而A呢？他会说“不是吧，我觉得不是这样的”、“这些道理虽然对，但是有点要求过高吧”，而往后，你所希望看到的变化还是没有发生，或者收效甚微。 当你的领导，愿意明确对你提出指导，不管是耐心的说教还是严厉的批评，你都应该抱着“有则改之无则加勉”的心态，即使要反驳，也要准备充分的理由和依据。面对领导的意见，要弄清楚其准确意图，然后实施针对性的改进措施。这就是团队里的游戏规则和生存之道。即使不是领导，是平级和下属，也应该采用类似的心态和应对方法。 7. Be logical. 有很好的条理，想事情做事情有逻辑很多程序猿，表达的时候通常是“我认为”、“我觉得”，或者说“听我的，只要这样这样，就能怎样怎样”但是一旦你追问其结论的依据，或者推导过程时，他又拿不出来。又或者，只知道埋头苦干，压根不管方向对错，轻重缓急。 程序猿是100%纯正的脑力工作者，但很多人却把自己变成体力工作者，自嘲自己身处劳动密集型产业，有的人甚至以日产出几千行代码为傲。这无疑是自废武功，自己把自己往“码农”的“农”字上推。定位问题，分析问题，解决问题，贯穿其中的都突出一个“逻辑”。无论是写设计文档、编写代码、测试，还是产品功能、用户需求、交互设计，概莫能外。先思考，谋定而后动，思考的过程，也就是找出因果关系，找出1234条论据以支持论点，找出step1 step2 step3 直至结果的推导步骤的过程。 当你有良好的条理性，有严谨的逻辑，也许凭直觉也能做出正确的判断。但时刻别忘了这一点。 8. Be thankful 懂得感恩什么是感恩？就是对指导、帮助、提携乃至批评过你的人的一种由衷的感激之情，懂得感恩的人都是善良的，善良且努力的人运气都不会太差（哈哈，仿烂鸡汤体）。只要你懂得感恩，甚至无需你做太多，只需要适时的表达，对方就能感受到你是孺子可教的，他就会觉得他的付出没有白费，而不是面对一个木头人或白眼狼。 同样还是上文的B童鞋，在我带过的几百人中间，他是最懂得感恩的一位。甚至于你在批评他的时候，他都会承认错误并感激你对他的指导。这样的人才，当他也拿出实实在在的业绩的时候，你怎能不提拔他？ 而作为对比，有太多的人，你曾经无数次的帮助过他，无论工作上还是生活中，但从未听到他的一句感谢。这样的人，只能呵呵以对。 9. Think beyond technology 不要只会纯技术化思维很多程序猿，痴迷于修炼技术，常常会在一个简单功能模块里面运用某某高深的算法和莫测的技术，纯粹为了炫技，而不去考虑是否过度优化，是否用户并不需要这么复杂的功能，是否投入产出比并不合理。无视用户、产品和市场规律的思考方式，就是纯技术化思维。 典型的一个案例是，（可能是处女座程序猿），所有的Bug都必须解完才可以发布版本，不管是不是犄角旮旯或耗时很久的。我在工作的第二年，我的领导跟我说了一个概念“Time to market”，让我意识到，你最关注的问题，或许并不是用户最关注的问题。你要做的，是应该快速把产品发布，再去倾听用户的呼声，可能100万用户里，都不会有人关注你花了几周时间死磕的问题，但他们会爆出更多更重要更迫切的问题。 10. Understand your products and users 理解你的产品和用户你要时刻关注你的产品，关注你的用户，从电商的网评，从售后的热线，从论坛的帖子，从行业外的朋友，获取他们对于你产品的第一手的评价。一个好的程序猿，也应该是一个好的产品经理。否则你就是一个缺乏大脑的泥瓦匠，而不是一个建筑师。 作为一个程序猿的leader，你是要代表团队去跟产品经理撕逼的，如果你不懂产品，那么你的团队也就完了。 11. Have good communication skills 良好沟通做一个牛逼的程序猿，其实可以不用怎么讲话，用牛逼的代码和运行结果去碾压别人即可。但如果你想做程序猿的leader，还继续保持这么高冷的姿态可不行。沟通无疑是管理的基础，一个程序猿想升职，想做管理，必然需要证明自己拥有不错的沟通能力。跟高层领导要资源，跟产品经理撕逼，跟测试部门搞好关系，跟设计妹子开开玩笑，跟程序猿搞基，不会沟通显然是不行的，最好是亦庄亦谐，荤素兼备。 这里不展开讲如何拥有良好的沟通技巧。只说几点：1. 沟通的意愿最重要，只要你愿意主动沟通，事情总会向好的方面发展。2. 沟通要真诚，不要套路。3. 口才不行，你可以多用写，写还有个好处就是留有证据，方便以后撕逼。 12. Take responsibility 承担责任常在河边走，哪有不湿鞋。代码写多了，挖坑是必然的。面对爆出来的Bug，面对领导的责备，没什么好说的，自己惹的，自己clean up。 放更长远来看，谁都会出错，不管你是程序猿，还是程序猿的leader，甚至是高管，总会被爆出问题。这时候是各种借口推诿，还是大大方方承认，并且用最快的速度处理干净？我认为正确的处理方式是后者，这不单单是能力问题，更多的是人品问题。 当你有朝一日当了leader，你手下犯了事，你也得大大方方站出来“我把关不严，责任我担”，绝不是把手下推出去了事（放你身上可能是小事，放他身上可能就得开除了），回过头再关起门内部处理。只有这样，你的手下才会服你，才会有人为你拼命干活。 最后，做不好管理就做纯技术，做资深专家、技术大拿也挺好，不要强扭。 第一次得到2K赞是始料未及的，有小小的惊喜。但也验证了那句话“林子大了，什么鸟都有”，许多负面的评论就冒出来了，有些我接受了，有些没忍住撕了一阵，有些看的我直乐。但始终没有被这些评论所烦扰，这是自己一年来最大的收获了。 一些质疑和回答质疑1：答主没提他是xx大学毕业的所以升职快？李开复哥大毕业，所以他的事业成功理所当然？拜托，哥大也是他考上的好吗，还不是回溯到他本身的努力和聪明。再者，这质疑的潜台词就是，xx毕业的才有可能升职这么快，不适用于其他人，大家散了吧。 以前也有类似的说法，背景论、阴谋论：比尔盖茨的母亲是IBM高管，巴菲特的父亲是国会议员，所以他们的成功无非就是靠背景，不过尔尔。可是企业高管的孩子，政府官员的娃，清华北大毕业生何止千万人，难道最终都是那么成功吗，为何比尔盖茨和巴菲特仅此一个？如果我们把别人的成功都归结于他所拥有的先天优势，忽略他们的聪明才智、开拓精神和巨大努力，这是在为甘于平庸和堕落找借口。请参考： 比尔盖茨的编程水平怎么样 实际上，所谓的成功学/成功经验的最大问题就是每个人的经历都是无法复制的。照着这些成功的经验去做，并不能保证你就一定飞黄腾达。更有人在评论里跟我纠结努力是不是成功的充分条件。用一句说烂了的话来讲“努力不一定能成功，但不努力一定不能成功”，明明说的是必要条件，硬要说我讲的是充分条件。有谁敢说找到了成功的充分条件，且具有可操作性？那成功都可以流水线批量生产了。当然这里有个目标定义的问题，什么是成功？升职加薪就是成功？不一定，每个人的目标都不一样，有的人还觉得过安逸的日子就是成功，这里就不赘言了。 质疑2：反对加班反对加班反对加班！升职加薪有那么重要，命都不要了？反对有效。我跟你一样反对，所谓的996、80小时、90小时，真的只是打比方。熬夜真的不好，12点前睡觉对程序猿来说真的太重要。早睡早起，坚持锻炼，这是程序猿必须牢记的，这十年里我庆幸自己一直坚持在打球，从未放弃。 但是！我们可以在不熬夜、尽量不伤害身体的情况之下比别人更加努力，别人打游戏，看电影，看网络小说的时间，你可以用来看书、编码和参加技术交流，然后按时睡觉。笨鸟先飞、天道酬勤，这难道不应该是绝大多数非清华北大学生，绝大多数自认为起点不高的人，绝大多数没有背景的人，应该相信和坚持的价值观吗？ 质疑3：天赋比努力更重要，没有天赋不要干程序猿这一行。我想举NBA的两个顶级球员来作为例子，麦迪和科比。天赋来看，麦迪天赋大大超过科比（臂展身高弹跳手掌大小），从努力程度来看，显然科比大大超过麦迪，最后谁的成就更高？当然你又可以扯队友、运气、伤病，等等。所以成功从来都不会有一个确定的公式，每个变量的权重大小早已明确，这是不可能的。詹姆斯、奥尼尔的成就里面天赋起很大作用，科比、AI、斯托克顿、纳什、库里更多的是靠勤奋的训练。 但最直接的反击是，给定一个人，他能不断提升自己的天赋吗？显然不能。要么努力，要么换行。纠结于那些我们无法改变的事情上面是没有意义的。鸡汤有云：努力改变那些我们能够改变的，接受那些无法改变的。我经常告诫自己：要么忍，要么狠，要么滚。 天赋决定了你的上限，勤奋决定了你的下限。你的上限可能比别人低，但你还是可以不断提升自己。 质疑4：你这是资本家的嘴脸，给大家洗脑，让大家做无脑员工，只知道埋头苦干被剥削。我的回答是：哈哈哈哈，真乐。被害妄想症，不要放弃治疗。鸡汤有毒你别喝就是。]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从数据库读取网站配置]]></title>
    <url>%2F2017%2F05%2F09%2FReadSiteConfigurationFromDatabase%2F</url>
    <content type="text"><![CDATA[近期遇到一个算是比较少见的需求，有点搞脑子，如果你也有类似的疑问，那么可以看看这篇文章。需求如下： 要经常改变网站的一些配置 这些配置除了显示也没什么用 通常可能会在全局使用 或许是一些分布式的配置 需要将配置存放在数据库 如果你的问题满足上述所述需求全部或者部分，不防阅读一下以下解决策略 因为以前的策略是把配置内容放在resources 下的*.properties 里面，而且为了省资源，在启动的时候把配置内容都加载到内存里，如果需求合理确实也没什么缺陷，但是最近运营推广上面有投放广告的需求，第三方推广公司对公司审核（某日头条、X60推广等），需要频繁修改网站名和公司名，这使得运维小哥非常恼火，而且重启容器确实不是一个很好的方案。那么，问题来了，这个锅我们服务端得背啊，额……不是，是身先士卒，能者多劳。经过一天的苦思冥想，大概有了下列几个方案： 放在数据库，加载到缓存，再加载到内存，刷新内存是一个问题 放在数据库，加载到缓存，不加载到内存，大量的修改和使用，工程量浩大 动态修改配置文件，需重启或更换读取方式 上下文监听器，可选重启，或者每个链接都刷新（缺点是所有请求都会触发，如图片） 文件监听器，需运维修改 …… 上述方案中，或多或少存在一些问题，和目前需求上也不是完全吻合，自然都被pass掉了。最终整理代码，还是想到了一个比较适合目前也可解决未来存在的潜在需求的方案，废话不多少，上方案。 把配置文件放到数据库中，可支持分布式读取 业务层和数据层增加缓存，减少数据库访问 读取配置加载到内存，并设置过期时间 JSP中导入工具类，读取就好了 那么问题又来了，工具类是静态的，如果业务层也是分布式，如dubbo等，配置从Service读取，存在一定的麻烦，好在之前就已经遇到过了，前面的文章里也讲过如何处理，看具体代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** 读取配置，放入值内存中 */ private static final Map&lt;String, String&gt; siteMap = Maps.newHashMap(); /** 读取配置，放入读取时间到内存中 */ private static final Map&lt;String, Long&gt; timeMap = Maps.newHashMap(); /** 超时毫秒数*/ private static final long EXPRE_TIME = 5 * 60 * 1000; @Autowired private SiteConfigService siteConfigService; private static SiteConfig siteConfig; @PostConstruct public void init() &#123; siteConfig = this; siteConfig.siteConfigService = this.siteConfigService; &#125; /** * 根据关键词读取配置 * @param key 关键词 * @return */ public static String read(String key) &#123; Long time = timeMap.get(key); if (null == time || expre(time)) &#123; // 刷新 SiteConfigModel config = siteConfig.siteConfigService.findByKey(key); if (null != config) &#123; String value = config.getValue(); logger.info("读取了配置:" + key + "=" + value); siteMap.put(key, value); timeMap.put(key, System.currentTimeMillis()); return value; &#125; return ""; &#125; else &#123; return siteMap.get(key); &#125; &#125;/** * 判断是否过期 * @param time 加入map的时间戳 * @return */ private static boolean expre(long time) &#123; if (System.currentTimeMillis() - time &gt; EXPRE_TIME) &#123; return true; &#125; return false; &#125; 前端使用就不讲了，再也不用要求改这改那的，你们爱改啥改啥，有时候，创新只是来源于偷懒！]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会写代码吗？]]></title>
    <url>%2F2017%2F02%2F13%2FDoYouReallyWriteCode%2F</url>
    <content type="text"><![CDATA[《编写可读代码的艺术》这本书我想程序猿都很熟悉吧。平时不怎么读书的我也是心血来潮将这本书通读了一遍，果然是大师写的书啊，让我感受颇深！下面是我从这本“神书”中摘抄的一些精华，千万不要错过： 把信息塞进名字中 避免空泛的名字，像tmp和retval，除非使用它们有特殊的理由。 使用具体的名字来更细致地描述事物——ServerCanStart()这个名字就比CanListenOnPort更不清楚。 给变量名带上重要的细节——例如，在值为毫秒的变量后面加上_ms。 为作用域大的名字采用更长的名字——不要用让人费解的一个或两个字母的名字来命名在几屏之间都可见的变量。对于只存 在于几行之间的变量用短一点的名字更好。 有目的的使用大小写、下划线等——例如，你可以在类成员和局部变量后面加上”_”来区分它们。 不会误解的名字是最好的名字 当要定义一个值的上限或下限时，max_和min_是很好的前缀。对于包含的范围，first和last是最好的选择。对于包含/排除范围，begin和end是最好的选择，因为它们最常用。 当为布尔值命名时，使用is和has这样的词来明确表示它是个布尔值，避免使用反义的词(例如disable_ssl)。 要小心用户对特定词的期望。例如，用户会期望get()或者size()是轻量的方法。 大家都愿意读有美感的代码 如果多个代码块做相似的事情，尝试让它们有同样的剪影。 把代码按”列”对齐可以让代码更容易浏览。 如果在一段代码中提到A、B和C，那么不要在另一段中说B、C和A。选择一个有意义的顺序并始终用这样的顺序。 用空行来把大块代码分成逻辑上的“段落”。 什么地方不需要注释 能从代码本身中迅速地推断的事实。 用来粉饰烂代码（例如蹩脚的函数名）的“拐杖式注释”——应该把代码改好。 你应该记录下来的想法 对于为什么代码写成这样而不是那样的内在理由（“指导性批注”）。 代码中的缺陷，使用像TODO：或者XXX：这样的标记。 常量背后的故事，为什么是这个值。 站在读者的立场上思考 预料到代码中哪些部分会让读者说：“啊？”并且给它们加上注释。 为普通读者意料之外的行为加上注释。 在文件/类的级别上使用“全局观”注释来解释所有的部分是如何一起工作的。 用注释来总结代码块，使读者不致迷失在细节中。 把更多的信息装入更小的空间里 当像“it”和“this”这样的代词可能指代多个事物时，避免使用它们。 尽量精确的描述函数的行为。 在注释中用精心挑选的输入/输出例子进行说明。 声明代码的高层次意图，而非明显的细节。 用嵌入的注释（如Function(/arg =/…)）来解释难以理解的函数参数。 用含义丰富的词来使注释简洁。 让代码的控制流更易读 在写一个比较时，把改变的值写在左边，并且把更稳定的值写在右边更好一些。 你也可以重新排列if/else语句中的语句块。通常来讲，先处理正确的/简单的/有趣的情况。有时这些准则会冲突，但是当不冲突时，这是要遵循的经验法则。 三目运算符必须在结构非常简单的情况下使用。 嵌套的代码块需要更加集中精力去理解。应该把它们改写成更加“线性”的代码来避免深嵌套。 通常来讲提早返回可以减少嵌套并让代码整洁。“保护语句”（在函数顶部处理简单的情况时）尤其有用。 减少变量的数量和让它们尽量“轻量级”来让代码更有可读性 减少变量，即那些妨碍的变量。 减小每个变量的作用域，越小越好。 只写一次的变量更好。那些只设置一次值的变量（或者const、final、常量）使得代码更容易理解。 最后送大家一句我最近喜欢的话：当才华还撑不起野心时，那你就应该静下心来学习！]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016新版支付宝APP支付的坑]]></title>
    <url>%2F2016%2F10%2F11%2F2016NewAlipayPaymentBug%2F</url>
    <content type="text"><![CDATA[半年前做了支付宝APP支付的接口的封装，没想到，才几个月，支付宝对接口整体做了一次更新，然而还是用老套路去开发的我，一路蒙逼，最后只好重新看了一遍文档，下面列举一下新旧版本或者本身就存在的坑。希望大家引以为戒！ 参数的变化新版本参数将业务参数封装到了biz_content，这是新增的一个参数，这个简单，不太容易入坑，只要逐一比对即可。建议将参数放到HashMap中,用JSON字符串输出就行，如：12345678Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();params.put("app_id", "");...Map&lt;String, String&gt; bizMap = new HashMap&lt;String, String&gt;();bizMap.put("seller_id", "");...params.put("biz_content", JSON.toJSONString(bizMap));return params; 签名内容改变这里开始就有点神经了，不得不吐槽，前后都不一致。首先，老版本加密的条件中，要把sign_type剔除再进行加密，现在的加密要把这个参数也进行加密，然而在最后进行通知验签的时候，这个字段又必须得剔除，对于支付宝公司的朋友，我只能呵呵了。大家自行脑补……o(∩_∩)o 最终结果url编码以前这个环节仅仅只要对key进行排序输出，现在多了对value进行url编码（即encode），不要仅对某几个参数进行encode，我就是这样进坑的，建议对之前的map进行排序输出的时候逐一编码，或者先全部编码再生成排序后的字符串。 通知验签这里跟以前没什么变化，所以才会出sign_type的幺蛾子，这里估计沿用老的接口，然后一个奇葩的事情出现了，恭喜你，程序都对，就是验签失败，最后你会发现，支付宝RSA公钥变了，是的，TMD公钥变了哈哈，当然刚开发的朋友不会有这个坑。 上面就是我碰到的比较典型的坑，最后还是希望大家开发的时候逐一比对文档吧，毕竟用人家的东西，得按人家的心思来。]]></content>
      <categories>
        <category>alipay</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring自定义扫描注解]]></title>
    <url>%2F2016%2F08%2F23%2FSpringCustomScanAnnotation%2F</url>
    <content type="text"><![CDATA[最近在做一个项目,首先是因为要在普通静态类里面调用Service,因为Service是Dubbo提供者的类,只能通过注解来调用.那么问题来了,该怎么调用Service呢? 静态类调用Service一般需要在一个工具类中使用@Autowired 注解注入一个service。但是由于工具类方法一般都写成static，所以直接注入就存在问题。可以这样解决:12345678910111213141516171819@Component public class TestUtils &#123; private static Logger logger = LoggerFactory.getLogger(OpeLogUtils.class); @Autowired private TestService testService; private static TestUtils testUtils ; public void setUserInfo(TestUtils testUtils ) &#123; this.testUtils = testUtils ; &#125; @PostConstruct public void init() &#123; testUtils = this; testUtils.testService= this.testService; &#125; &#125; @PostConstruct 是spring标签,相当于在配置文件声明注入 如何让Spring扫描该静态类这样通过testUtils.testService调用即可.那么问题来,这样做了以后你会发现spring依旧不加载testService,声明没有执行,这里别忘记在上面的代码中声明一个Spring注解,如@Component可能有的同学到这一步是成功,因为你可能是默认配置,默认配置是扫描base-package下所有的注解,这样性能肯定不好,勤学苦练,苦思冥想,终于让我找到配置起来比较高逼格的做法,话不多说,上代码: 12345678&lt;!-- 自动扫描，完成bean的创建和依赖注入 --&gt; &lt;context:component-scan base-package="com.example" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component" /&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Service" /&gt; &lt;context:exclude-filter type="regex" expression="com.example.controller"/&gt; &lt;context:exclude-filter type="regex" expression="com.example.service"/&gt; &lt;/context:component-scan&gt; 稍微解释下,在xml配置了&lt;context:component-scan&gt;这个标签后，spring可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean注意：如果配置了&lt;context:component-scan&gt;那么&lt;context:annotation-config/&gt;标签就可以不用再xml中配置了，因为前者包含了后者。另外&lt;context:annotation-config/&gt;还提供了两个子标签 &lt;context:include-filter&gt; 和&lt;context:exclude-filter&gt;在说明这两个子标签前，先说一下&lt;context:component-scan&gt;有一个use-default-filters属性，改属性默认为true,这就意味着会扫描指定包下的全部的标有@Component的类，并注册成bean.也就是@Component的子注解@Service,@Reposity等。所以如果仅仅是在配置文件中这么写1&lt;context:component-scan base-package="com.example"/&gt; use-default-filter此时为true那么会对base-package包或者子包下的所有的进行java类进行扫描,并把匹配的java类注册成bean。 可以发现这种扫描的粒度有点太大，如果你只想扫描指定包下面的Controller，该怎么办？此时子标签&lt;context:incluce-filter&gt;就起到了勇武之地。如下所示 123&lt;context:component-scan base-package="com.example.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; 这样就会只扫描base-package指定下的有@Controller下的java类，并注册成bean但是因为use-dafault-filter在上面并没有指定，默认就为true，所以当把上面的配置改成如下所示的时候，就会产生与你期望相悖的结果（注意base-package包值得变化） 123&lt;context:component-scan base-package="com.example.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; 此时，spring不仅扫描了@Controller，还扫描了指定包所在的子包service包下注解@Service的java类此时指定的include-filter没有起到作用，只要把use-default-filter设置成false就可以了。这样就可以避免在base-packeage配置多个包名这种不是很优雅的方法来解决这个问题了。另外在我参与的项目中可以发现在base-package指定的包中有的子包是不含有注解了，所以不用扫描，此时可以指定&lt;context:exclude-filter&gt;来进行过滤，说明此包不需要被扫描。综合以上说明Use-dafault-filters=”false”的情况下：&lt;context:exclude-filter&gt;指定的不扫描，&lt;context:include-filter&gt;指定的扫描这个配置文件中必须声明xmlns:context 这个xml命名空间，在schemaLocation中需要指定schema：12http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-3.0.xsd 这个文件中beans根节点下只有一个context:component-scan节点，此节点有两个属性base-package属性告诉spring要扫描的包，use-default-filters=”false”表示不要使用默认的过滤器，此处的默认过滤器，会扫描包含Service,Component,Repository,Controller注解修饰的类，而此处我们处于示例的目的，故意将use-default-filters属性设置成了false。 context:component-scan节点允许有两个子节点&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;。filter标签的type和表达式说明如下： Filter Type Examples Expression Description annotation org.example.SomeAnnotation 符合SomeAnnoation的target class assignable org.example.SomeClass 指定class或interface的全名 aspectj org.example..*Service+ AspectJ语法 regex org.example.Default.* Regelar Expression custom org.example.MyTypeFilter Spring3新增自定Type，org.springframework.core.type.TypeFilter 在我们的示例中，将filter的type设置成了正则表达式，regex，注意在正则里面.表示所有字符，而.才表示真正的.字符。我们的正则表示以Dao或者Service结束的类。 我们也可以使用annotaion来限定，如下： 1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:context="http://www.springframework.org/schema/context"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;&lt;context:component-scan base-package="cn.outofmemory.spring" use-default-filters="false"&gt;&lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt;&lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 这里我们指定的include-filter的type是annotation，expression则是注解类的全名。 另外context:conponent-scan节点还有&lt;context:exclude-filter&gt;可以用来指定要排除的类，其用法和include-filter一致。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用markdown来写api]]></title>
    <url>%2F2016%2F06%2F15%2FUseMarkdownToWriteAPI%2F</url>
    <content type="text"><![CDATA[一直在找寻最合适的方法来实现api接口文档的书写，直达发现了markdown,虽然也用markdown，却从来没想过可以这么优雅地来写api哈。那么开始get新技能吧。 ##接口文档 [TOC] 查询指定项目属性 接口功能 获取制定项目的分类信息 URL http://www.api.com/index.php 请求参数 参数 必选 类型 说明 name ture string 请求的项目名 type true int 请求项目的类型。1：类型一；2：类型二 。 返回字段 返回字段 字段类型 说明 status int 返回结果状态。0：正常；1：错误。 company string 所属公司名 category string 所属类型 接口示例 地址：http://www.api.com/index.php?name=”可口可乐”&amp;type=112345&#123; "statue": 0, "company": "可口可乐", "category": "饮料",&#125; 下面是源代码1234567891011121314151617181920212223242526272829303132333435##接口文档[TOC]***### 查询指定项目属性 **接口功能**&gt; 获取制定项目的分类信息 **URL**&gt; http://www.api.com/index.php**请求参数**&gt; |参数|必选|类型|说明||:----- |:-------|:-----|----- ||name |ture |string|请求的项目名 ||type |true |int |请求项目的类型。1：类型一；2：类型二 。|**返回字段**&gt; |返回字段|字段类型|说明 ||:----- |:------|:----------------------------- ||status |int |返回结果状态。0：正常；1：错误。 ||company |string | 所属公司名 ||category |string |所属类型 |**接口示例**&gt; 地址：[http://www.api.com/index.php?name="可口可乐"&amp;type=1](http://www.api.com/index.php?name="可口可乐"&amp;type=1)``` javascript&#123; "statue": 0, "company": "可口可乐", "category": "饮料",&#125; 最后的`自己补上 但是markdown还是有缺陷，比如toc问题，兼容性问题等。最佳效果是wiki配上markdown，这样内部沟通问题很好解决。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年小谈]]></title>
    <url>%2F2016%2F02%2F05%2F2015YearTalk%2F</url>
    <content type="text"><![CDATA[年关将近，到了该说说有些话的时候了。回首2015，经历的很多，得到的很多，成就的很少。下面，来数数那些坑爹的人和事： 工作经验上半年14年底来到某塑，一心想着大展拳脚，实现理想和报复，忽略了太多细节。性格方面的因素注定我要在这场轰轰烈烈的斗争中失败，结局也不是谁胜谁负，那半年，比较迷茫，搞不清自己追求的到底是什么。生活上，工作上的双重压力，促使那场决战的爆发。或许是没有准备好去扮演那样的角色吧，年轻的我还不适合当一名领导者。不过我还是会坚持自己的理念，力图打造自己和其他程序员满意的环境。 下半年从上一岗位退出，自视能力还有待提高，于是继续应聘基层工作。选择了自以为还比较合适的一家单位，年轻气盛地我，进入公司后忍受不了长期的雪藏。于是拼命想展现自己，却忽略了职场生活中的至关重要的细节。每一家公司都有其运行的状态，不同的状态需要不同的人，也会有不同的人应运而生。工作才一年，又没有认真去思考过这些问题，导致对公司情况认识不足。那时的我，全身心投入到公司的建设，因为是第一个员工，也尽心尽力做好每一件事，至少出手的东西都是自己所认可的。慢慢地，干掉了自己应该干、不应该自己干的所有的活，终于矛盾触发，触及到他人的利益。从没有想过有朝一日自己会面临这种窘境，并不是全心全意地付出就能得到应有的回报，公司资源有限，能给到的利益只有那么多，还存在致命地内耗。所以枪打出头鸟，这时候你的努力对于他人来说便是一种威胁。结果可想而知。 思想境界 活是干不完的 不是说干活拖拉或者只做自己该做的事情，自己该做的事情，应该保持高效，做完了多注重自我的提升。不仅如此，要耐住寂寞，做好“路漫漫其修远兮，吾将上下而求索”的决心。 韬光养晦 无需急着表现自己，只有生存下去才是王道，加强自我提升。枪打出头鸟，职场新人，切勿锋芒毕露。 不忘初心 不论在什么时候，都要保持最初的那份心，对自己喜爱的事情持之以恒，成功往往离不开不放弃。 弥足珍贵 在这个纷杂的世界里，最珍贵的友情。职场中往往没有朋友，因为到处充斥着硝烟的味道，有了利益冲突，再高洁的人都会堕落。为了保证自己不堕落，区分哪些人是真朋友，哪些人是假朋友。所以同窗、发小、老友都是一生中可能最宝贵的财富，珍惜现在的朋友，保持那些年的童真。 代码世界作为程序员，如果连代码积累都没有，那这一年真是白活了，下面回忆一下自己今年接触的新鲜事吧： angular.js spring-boot jpa-data 禅道项目管理 solr BootStrap 前端框架 maven私服nexus douku wiki Mybatis整合dubbo layer 消息提示 HandlebarsJS 一款模版引擎 工商银行网银支付开发 redis nginx 自动化测试：RBF+Selenium2 持续集成：Jenkins+sonar hexo 微信公众号开发 可能再多就记不起来了，想想这一年，好像弄过的还挺多哈。虽然经济上并没有什么大的变化，我始终相信，持之以恒，面包会有的，鲜花也会有的！ 尾声希望所有的好友日子都能好起来。大神、勇见、洛洛、明明、毛毛、杨杰、金鑫、贺鑫、智达、小刚新年快乐。单身的赶紧找另一半，有主的趁早结婚，事业有成！]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员修炼之道]]></title>
    <url>%2F2016%2F02%2F04%2FThePragmaticProgrammer%2F</url>
    <content type="text"><![CDATA[多码代码，多思考，少敲bug，少跟产品干架 看看月薪3万的程序员都避开了哪些坑： 习惯即刻回报他不懂得只有春天播种，秋天才会有收获。刚刚付出一点点，甚至还没有付出，就想要得到回报。技术刚刚掌握，能一边百度一边干活了就觉得该拿到多少多少钱了。找工作先想着多少多少钱，入职了没干几个月就想着要加多少多少钱，干了没几个月，薪水要是没涨，就放弃了，准备通过跳槽加薪，不跳槽的话，往往也会因为没加薪而牢骚满腹，工作敷衍了事。 一个程序员的价值，是通过他带给公司的价值体现的。先给公司带来了价值，然后才会反过来在薪水上体现出自己的价值。公司都很现实，很少会为你的潜力买单，在你还没有体现出价值时就给你很高的薪水。 在生活和工作中，一定要懂得付出，不要那么急功近利，马上想得到回报。天下没有白吃的午餐，你想获得什么，就得先付出什么。唯有种下种子，然后浇水、施肥、除草、杀虫，然后才能等来收获。 缺乏学习热情很少有哪个岗位的人像程序员这样需要持续不断的学习，软件开发的技术日新月异，而每一项技术又往往博大精深，不持续、深入钻研是很难掌握的，更别谈精通了。如果你对一项技术不能深刻理解熟练应用，表现出来的水准仅仅是能干活、还行，那很难说会有公司愿意为“还行”付出大的代价，只有脱颖而出，才可能备受重视。 假如你对学习、掌握、精通技术没有兴趣，面对不断涌现的新语言新技术新框架没有学习欲望，那但就软件开发这个工作而言，你不但眼下不太可能拿到高薪，将来也不会。在这样一个快速变化的时代，只有不断地学习才不会被抛弃。 不够努力虽然我们都知道努力学习可以改变我们的技能水平，持续努力不懈坚持可以让自己有所建树，可还是有很多人浅尝辄止，三天打鱼两天晒网，搞两下能Run就放下了。 人和人在聪明才智上的差距并没有想象中大，甚至很多时候，从大多数人的努力程度之低来看，根本还轮不到拼天赋。如果两个人的实力半斤八两的话，热情工作努力坚持的人，一定比较容易成功。 畏难做事拈轻怕重，不愿挑战。殊不知能力就是在不断挑战不断突破自己的过程中历练出来的。在一个公司里面，经常承担高难度任务的程序员，一定是成长比较快的，薪水增长也一定是比较快的。越是困难的事情，越能体现出个人价值，也越能带给个人成长。 万事起头难，不要害怕困难。事情做不好往往不是因为没有能力，大都是由于缺乏恒心。只要不怕困难，坚持前行，一定会有不一样的收获。 事业就像女人，谁去追求，谁就能得手。金钱也一样。 缺乏责任心工作上不管什么事儿，反正不是自己的事儿，缺乏责任心，干好干不好都无所谓，对交付承诺、对产品质量都不在意，没什么事儿能让他上心。 一个人的责任心如何，决定着他在工作中的态度，决定着其事业的好坏和成败。如果一个人没有责任心，即使他有再大的能耐，也不一定能做出好的成绩来。 消极，抱怨工作稍有不顺，就怨气沸腾，这个怎么怎么样，那个怎么怎么样，而我怎么就这样，任务不公平，资源不公平，那谁谁不支持我，那谁谁不配合…… 抱怨不能使事情变好，反之，它会让负面情绪蔓延，蚕食你的精力和时间，让你产出更低。成功者永不抱怨，抱怨者永不成功。立刻停止抱怨，早一分钟停止，你就离目标近一分钟。 没有时间管理观念每个人的一天都只有24小时，人和人的差别就在于如何利用时间上。 有的人每周都有目标，每天都有计划，早上起来会想今天要做的几件重要的事，晚上会回顾今天完成的事，总结干成了什么干坏了什么，还会有计划的学习新知识新技能，这样日积月累不断坚持，每一天都是高效的，每一天都朝着更丰富更完美的自己前进。 而有的人则漫无目的，走哪算哪，到了公司，上午基本做不成事儿，到下午了还不知道要做什么，晚上也发愁如何消磨时间…… 为薪水工作虽然工作的一大目的是获取薪水，养活自己以及供给家庭所需;但是，这只是工作最直接的报偿，同时也是最低级的目标。 如果我们为薪水而工作，将注定我们是短视的，也将注定受到最深的伤害。假如你看不到工资以外的东西，斤斤计较于薪水、福利、职位等，那外界的些微风吹草动就可能让你像浮萍一样飘来荡去，你很快就会失去平衡，失去信心，失去热情，失去平和，进而在工作时总是采取一种应付了事的态度，能少做就少做，能躲避就躲避，觉得只要对得起自己的那份薪水就成了。长此以往，你追求的高薪水反倒得不到。 我们进入一个公司工作，是为了自己，不是薪水也不是别人，比薪水更重要的，是成长和成就自己的机会。我们一定要明白，公司、企业、组织，都是我们锻炼自己、修炼自我的平台，我们不是为薪水工作、不是为老板工作、不是为家人工作，是为实现自我而工作，是为更完美的自己而工作。 唯有志存高远，方能风行天下。 其实不喜欢软件开发有一部分人从事软件开发工作，并不是因为喜欢，也没有干着干着从不喜欢变成喜欢。他们可能是喜欢软件开发附带的高薪水——平均薪水比其他行业高。人做一件自己不喜欢的事情时，心理上没有亲近感，不会想着怎样把事情做得更好，往往是差不多就成了，不太可能有精益求精积极向上的追求。因为在做不喜欢的事情时，情感上是拒绝的，情绪上是想逃离的，总想着早点儿完事儿拉倒，每一天去单位时不是充满期待，而是各种担忧、烦躁、畏惧，到了单位，稍有困难或不顺心，就会消极、抱怨、抵触、拒绝…… 做喜欢的事，能最大可能发挥一个人的潜能和热情，会最快速地通向成功成就自己。而做不喜欢的事，一开始就注定了事倍功半，最后也往往会是痛苦不堪或半途而废。 不要和比你差的人比较即使现在他的工资可能比你高，不要觉得不公平，社会本就没有公平可言，有着一日，你的工资绝对会在他之上，前提是保证自己做到最好，做事先做人。 少干嘴架干嘴架赢了一时爽，并不会对你敲代码有所提升，理清思路，以需求为原则，站在合理的角度看待需求]]></content>
      <categories>
        <category>涂鸦</category>
      </categories>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeLinter如何校验html、js、css]]></title>
    <url>%2F2016%2F02%2F01%2FSublimeLinterHowToUse%2F</url>
    <content type="text"><![CDATA[SublimeLinter是Sublime的一个代码检测工具插件。但是要正常使用它,还需要安装相应的插件。 Html校验工具 先安装SublimeLinter-contrib-htmlhint,很简单,ctrl+shift+p 直接install; 安装htmlhint,打开cmd; npm install -g htmlhint@latest 检查安装是否完成; htmlhint --version Js校验工具 先安装SublimeLinter-jshint; 安装jshint; npm install -g jshint 检查安装是否完成; jshint -v Css校验工具 先安装SublimeLinter-csslint; 安装csslint npm install -g csslint 检查安装是否完成 csslint --version 好了,这样应该就可以自动校验了.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端大杀器 Sublime 3安装和常用插件]]></title>
    <url>%2F2016%2F01%2F26%2FSublime3InstallAndPlugin%2F</url>
    <content type="text"><![CDATA[SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。这些非常棒的特性 包括任意跳转（Goto Anything）、多重选择（multiple selections）、指令面板（command palette）、免打扰模式（distraction free mode）、分区编辑（split editing）、快速项目切换（instant project switch），你还可以随意地自定义更多功能。还有，这款编辑器支持Mac、Windows和Linux平台。 安装1.官网下载最新版，可以选择text2或者text3，我选择的text3，它出来也很久啦，很多方面已经得到了完善。2.度娘一下激活码，大多都是可以用的，当然不用激活码也没事，它是无限试用的。3.有需要可以汉化，其实也没必要，就是一些菜单而已。也不难，网上随意搜下汉化包放到指定位置即可。 插件SublimeText本身已经非常强大，但是更棒的是有一长串的插件支持它，给它带来更强大的功能。本文将介绍一些 Sublime Text 3 支持的热门插件（Sublime Text 2 的一些插件在 Sublime Text 3 上不支持）。 Package ControlPackage Control 插件是一个方便 Sublime text 管理插件的插件，但因为 Sublime Text 3 更新了 Python 的函数，API不同了，导致基于 Python 开发的插件很多都不能工作，Package Control 原来的安装方法都失效了。 网上有2种使用 Git 的安装方法，感觉太麻烦了。此处将 wbond 网站的 ST3 Package Control 简便安装方法翻译转至此处，方便大家查阅。 简单的安装方法：从菜单 View - Show Console 或者 ctrl + ~ 快捷键，调出 console。将以下 Python 代码粘贴进去并 enter 执行，不出意外即完成安装。以下提供 ST3 和 ST2 的安装代码：Sublime Text 3： import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())` Sublime Text 2： import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) EmmetEmmet 是一个前端开发的利器，其前身是 Zen Coding。它让编写 HTML 代码变得简单。Emmet 的基本用法是：输入简写形式，然后按 Tab 键。安装请使用上面的插件哦！ 关于 Emmet 的更多用法，请看官方文档，这份速查表可以帮你快速记忆简写形式。 Soda ThemeSoda Theme 是最受欢迎的 Sublime Text 主题。现在Soda集成了Light和Dark，以前是要分开下的呢。话不多说，上使用方法：在你的配置文件（菜单 Preferences -&gt; Settings - User）中加入”theme”: “Soda Light.sublime-theme” 或 “theme”: “Soda Dark.sublime-theme” SublimeLinterSublimeLinter 是一个代码校验插件，它可以帮你找出错误或编写不规范的代码，支持 C/C++、CoffeeScript、CSS、Git Commit Messages、Haml、HTML、Java、JavaScript、Lua、Objective-J、Perl、PHP、Puppet、Python、Ruby 和 XML 语言。 SublimeLinter 默认以 background 模式运行，在用户输入的同时即时校验，如果你想要 Sublime Text 运行得更流畅，可以空白处右键改为 load-save 模式或 save-only 模式，在读取和保存是校验或只在保存时校验。 Sublime​Code​IntelSublime​Code​Intel 是一个代码提示、补全插件，支持 JavaScript、Mason、XBL、XUL、RHTML、SCSS、Python、HTML、Ruby、Python3、XML、Sass、XSLT、Django、HTML5、Perl、CSS、Twig、Less、Smarty、Node.js、Tcl、TemplateToolkit 和 PHP 等语言，是 Sublime Text 自带代码提示功能的很好扩展。它还有一个功能就是跳转到变量、函数定义的地方，十分方便。 AlignmentAlignment 是一个代码格式化插件，它可以使多行代码中的等号对齐，也可以调整多行代码为一个缩进级别，默认快捷键是 ctrl+alt+a（Mac OS 上是 cmd+ctrl+a）。跟QQ截图冲突了？自己改下吧，我改成了ctrl+shift+a。 ColorPicker在编辑CSS样式的时候，要加个自己喜欢颜色或改改颜色啥的，要到PS里去调色？ColorPicker 可以让 Sublime Text 3内置一个调色盘，调好颜色，点击OK就会在光标处生成十六进制颜色代码。 CssComb这是用来给CSS属性进行排序的格式化插件。如果你想保持的代码干净整洁，并且希望按一定的顺序排列（是不是有点强迫症了？），那么这个插件是一种有效解决的方案。特别是当你和其他有自己代码编写风格的开发者一同协作的时候。 ConvertToUTF8Sublime原生不支持GBK等编码，打开这类编码文件时中文或一些字符都乱码了，安装该插件即可解决 HTML5&amp;HTMLattributes这两个插件对弥补了sublime对html5支持度不足的缺陷 Jquery顾名思义，包含jquery函数 CodeFormatter可以对html、JS、CSS、PHP、python代码格式化的插件 默认快捷键ctrl+alt+F，如果想对PHP格式化，需要到该插件默认设置中设定php.exe的路径 BracketHighLighter括号、标记高亮等等，挺好用的，只是偶尔识别错误 DocBlockrDocBlockr 可以使你很方便地对代码建立文档。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。 JsFormat一个JS代码格式化插件。 MarkdownEditing此篇博客用到了该插件 OmniMarkupPreviewer用来预览markdown的插件，相同功能的有Markdown Preview]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
